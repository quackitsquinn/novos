use alloc::vec::Vec;
use x86_64::{
    structures::paging::{PageTable, PageTableFlags},
    VirtAddr,
};

use crate::println;

use super::{MEMORY_OFFSET, OFFSET_PAGE_TABLE};

#[derive(Debug, Clone, Copy)]
pub struct VirtRange(pub VirtAddr, pub usize);

fn find_used_pages(pgtbl: &PageTable) -> Vec<VirtRange> {
    let mut used = Vec::new();
    let iter = find_used_pages_inner(pgtbl, &mut used, 0, 0);
    println!("Iterated over {} entries", iter);
    // Combine adjacent ranges
    let mut combined = Vec::new();
    let mut last: Option<VirtRange> = None;
    for range in used {
        if let Some(mut last) = last {
            if last.0 + last.1 as u64 == range.0 {
                last.1 += range.1;
                continue;
            } else {
                combined.push(last);
            }
        }
        last = Some(range);
    }
    if let Some(last) = last {
        combined.push(last);
    }
    combined
}

fn find_used_pages_inner(
    pgtbl: &PageTable,
    used: &mut Vec<VirtRange>,
    addr: u64,
    level: u8,
) -> usize {
    let mut iter_count = 0;
    for i in 0..512 {
        let entry = &pgtbl[i];
        iter_count += 1;
        if entry.is_unused() {
            continue;
        }

        let addr = addr | (i as u64) << (12 + level * 9);
        if level != 3 {
            iter_count += find_used_pages_inner(
                unsafe {
                    &*((entry.addr().as_u64() + MEMORY_OFFSET.get().expect("no offset"))
                        as *const PageTable)
                },
                used,
                addr,
                level + 1,
            );
        } else {
            used.push(VirtRange(VirtAddr::new_truncate(addr), 4096));
            break;
        }
    }
    iter_count
}

#[derive(Debug)]
pub struct VirtualAddressMapper {
    unused: Vec<VirtRange>,
}

impl VirtualAddressMapper {
    pub fn from_used_pages(used: Vec<VirtRange>) -> Self {
        let mut unused = Vec::new();
        let mut last = VirtAddr::new(0);
        for range in used {
            if last < range.0 {
                unused.push(VirtRange(
                    last,
                    range.0.as_u64() as usize - last.as_u64() as usize,
                ));
            }
            last = range.0 + range.1 as u64;
        }
        Self { unused }
    }

    pub fn allocate(&mut self, size: usize) -> Option<VirtRange> {
        for range in &mut self.unused {
            if range.1 >= size {
                let addr = range.0;
                range.0 += size as u64;
                range.1 -= size;
                return Some(VirtRange(addr, size));
            }
        }
        None
    }

    pub fn deallocate(&mut self, range: VirtRange) {
        for range in &mut self.unused {
            if range.0 == range.0 + range.1 as u64 {
                range.1 += range.1;
                return;
            }
        }
    }
}

pub fn init() {
    let pgtbl = OFFSET_PAGE_TABLE.get();
    let used = find_used_pages(pgtbl.level_4_table());
    println!("Used pages: {:?}", used);
}
